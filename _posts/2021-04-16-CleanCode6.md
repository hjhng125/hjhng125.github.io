---
title:  "Clean Code 6장 - 객체와 자료구조"

categories:
  - clean-code
comments: true
last_modified_at: 2021-04-20
---

### 변수를 비공개로 하는 이유
변수를 private로 선언하는 이유는 남들이 변수에 의존하게 만들고 싶지 않기 때문이다.
즉, 변수의 타입이나 구현을 마음대로 바꾸게 하기 위함이다.

그렇다면 왜 변수는 private으로 하고 getter, setter는 public으로 구현하는 것일까

## 자료 추상화
* 인터페이스는 자료구조를 명백하게 표현한다.

변수를 private이라고 선언하더라도 getter, setter를 제공한다면 구현을 외부로 노출하는 것이다. <br>
변수 사이에 함수를 넣는다고 구현이 감춰지지는 않는다.

구현을 감추기 위해선 추상화가 필요하다. <br>
추상 인터페이스를 제공하여 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 클래스다. <br>
추상화를 사용하더라도 자료를 세세하게 제공하기보다 추상적인 개념으로 표현하는 편이 좋다. <br>

개발자는 자료를 표현할 가장 좋은 방법을 항상 고민해야 한다. <br>
아무 생각 없는 getter/setter는 지양하자

## 자료 / 객체 비대칭

* 객체 : 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공
  * 객체 지향적
  * 새로운 클래스를 추가해도 아무런 영향이 없다.
  * 함수를 추가하면 모든 클래스가 영향을 받는다.

* 자료구조 : 자료를 그대로 공개하며 별다른 함수를 제공하지 않는다.
  * 절차 지향적
  * 함수를 추가하는 것은 아무런 영향이 없다.
  * 새 자료구조를 추가한다면 모든 함수를 고쳐야 한다.

## 디미터 법칙
모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.

클래스 C의 메서드 f는
* 클래스 C
* f가 생성한 객체
* f의 인수로 넘어온 객체
* C의 인스턴스 변수에 저장된 객체

만 호출해야 한다.

* 기차 충돌 - 여러 객체가 한 줄로 이어진 기차처럼 보이는 코드

```
final String outputStr = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

아래와 같이 수정하는 것이 좋다.

```
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDit = scratchDir.getAbsolutePath();
```

위 코드의 형태로 
* ctxt가 Options를 포함한다는 것을 알 수 있다.
* Options가 ScratchDir을 포함한다는 것을 알 수 있다.
* ScratchDir가 AbsolutePath를 포함한다는 것을 알 수 있다.

만약 위 대상들이 객체라면 디미터 법칙을 위반한다.<br>
하지만 자료구조라면 아래와 같이 변경하면 괜찮다.

```
final String outputDir = ctxt.options.scratchDir.absolutePath;
```

## 잡종구조
절반은 객체, 절반은 자료구조인 형태

* 단순한 자료구조에도 getter / setter를 정의하라는 프레임워크와 표준이 존재한다. (bean)
* 중요 기능을 수행하는 함수와 public 변수
* private 변수를 노출하는 getter / setter

이러한 잡종구조는 새로운 함수나 자료구조를 추가하기 어렵게 한다.

## 구조체 감추기
만약 위의 ctxt가 객체라면 `뭔가를 하라고 말해야지` 속을 드러내라고 말하면 안된다. <br>
위의 예제에서 절대경로가 필요한 이유는 임시 파일을 생성하기 위함이다. <br>
그렇기에 아래와 같이 파일을 생성하는 함수를 만든다.

```
BufferedOutputStream bufferedOutputStream = ctxt.createScratchFileStream(classFileName);
```

ctxt는 내부 구조를 드러내지 않고 해당 함수는 자신이 몰라도 되는 객체를 탐색하지 않아도 된다.

## 자료 전달 객체 - Data Transfer Object
자료구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스이다.

* 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.
* 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 사용

### 활성 레코드
DTO의 특수한 형태

공개 변수가 있거나 비공개 변수의 getter / setter 함수가 있는 자료 구조지만, save, find 등의 탐색 함수도 제공한다.


> 필자는 DTO클래스에 비즈니스 규칙 메소드를 추가하곤 했다. <br>
하지만 이 습관이 잡종 구조를 만들어낸다는 것을 알게되었다. <br>
그렇기에 이를 구분하여 비즈니스 로직이 필요하며 내부 자료를 숨기는 객체는 따로 생성해야 겠다.


* 새로운 자료 타입을 추가하는 것은 객체가 적합
* 새로운 동작을 추가하는 것은 자료구조와 절차적 코드가 적합
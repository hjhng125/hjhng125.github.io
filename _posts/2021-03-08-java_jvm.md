---
title:  "JVM"
excerpt: "JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가."

categories:
  - java
tags:
  - JVM
comments: true
last_modified_at: 2021-03-08
---


* JVM이란 무엇인가
  * Java Virtual Machine의 약자로 자바 가상 머신을 의미한다.
  * WORA(Write Once Run Anywhere)를 추구한다.
    - 한번 작성하여 어디서든 실행할 수 있다
    - 자바 컴파일러는 .java 파일을 .class라는 Java Byte Code로 변환한다. 
    - JVM은 컴파일된 Java Byte Code를 OS에 맞게 해석해주는 역할을 한다.
    - 이는 곧 운영체제에 독립적으로 실행할 수 있음을 의미한다.
    - OS마다 다른 프로그램을 만들 필요없이 해당 OS에 맞는 JVM을 설치하면 알아서 Byte Code를 기계어로 번역해준다.
  * 위의 과정으로 인해 번역을 하지 않는 타 언어보다 느리다는 단점이 있었지만 JIT 컴파일러를 구현하여 극복하였다.

* JVM의 구성요소
  * 클래스 로더 (Class Loader)
    * 컴파일되어 생성된 .class들을 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area로 적재하는 역할을 함.

  * 실행 엔진 (Execution Engine)
    * 클래스 로더에 의해 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행하는 역할
    * 명령어를 하나하나 실행하는 인터프리터 방식과 JIT 컴파일러를 이용하는 방식이 있음.
      - JIT 컴파일러
        - 일정 시간동안 인터프리터가 코드를 해석하며 컴파일하기에 충분할 정도로 자주 호출되는 메소드가 무엇인지 알아내고, 해당 메소드만 컴파일하는 방식
        - 자주 실행되는 영역만을 컴파일한다.
  * GC
    * 자바는 메모리 관리를 JVM이 알아서 해준다.
    * 더이상 참조되지 않고 있는 메모리를 정리해준다.
    * 언제 호출되는지는 알 수 없으며, 사용자가 호출해도 메모리 정리가 필요없다고 판단되면 실행하지 않는다.
  * Runtime Data Area (JVM의 메모리 영역)
    * 메서드 영역 
    * 힙 영역
    * 런타임 스택 영역
    * 네이티브 메서드 스택 영역
  

* 컴파일 하는 방법
  * 컴파일이란 .java파일을 .class파일로 변환시키는 작업이다.
  * JDK내의 javac라는 컴파일러가 포함되어 있는데, 이 명령어를 통해 컴파일한다.
    * javac main.java
  * javac option

    |옵션|설명|예제|
    |---|---|---|
    |-classpath, -cp|클래스패스(실행할 클래스의 위치를 지정)|javac -cp "/users/main.java"|
    |-d|클래스 생성 위치 지정(default는 소스파일이 위치한 곳)|javac -d "/users/path"|
    |-encoding|소스 파일에 사용된 인코딩을 설정|javac -encoding "utf-8" "/users/main.java"|
    |-g|모든 디버깅 정보 출력|javac -g "/users/main.java"|
    |-verbose|컴파일러가 진행하는 작업 출력|javac -verbose "/users/main.java"|
    |-sourcepath|소스파일 위치 지정|javac -sourcepath "/users/path"|
    |-source|소스파일 자바 버전 지정|javac -source 1.8 "/users/main.java"|
    |-target|타겟파일 자바 버전 지정|javac -target 1.8 "/users/main.java"|

* 실행하는 방법
  * java main.class
  * 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

* JVM의 메모리 영역  
  * PC Register
    - CPU가 연산을 하는 동안 필요한 정보를 저장
  * 메서드 영역 (Method area) - 쓰레드 공유
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보(class data)를 이곳에 저장한다.
    - Class 객체(Reflection에 이용됨), Constant Pool(상수 풀), 클래스 변수 (class variable) 또한 이 영역에 함께 생성된다.
  * 힙 영역 (Heap area) - 쓰레드 공유
    - 인스턴스가 생성되는 공간.
    - 프로그램 실행 중 생성되는 인스턴스는 모두 이 영역에 생성된다.
    - 즉, 인스턴스 변수들이 생성되는 공간이다.
    - 메서드 영역에 로드된 클래스만 생성 가능하며, GC가 참조되지 않는 메모리를 확인하고 제거하는 영역
  * 호출스택 (Call stack or Execution stack)
    - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.
    - 메서드가 호출되면, 호출스택에 메서드를 위한 공간이 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.
    - 메서드가 작업을 마치면, 호출스택에 할당되었던 메서드의 메모리는 반환되어 비워진다.
  
      ```
1. 메서드가 호출되면 수행에 필요한 만큼 메모리를 스택에 할당받는다.
2. 메서드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.
3. 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
4. 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
  ```

  * 네이티브 메서드 스택 영역 (Native Method Stack)
    - 자바 언어가 아닌 다른 언어로 작성된 Native한 코드를 위한 stack (JNI) 


* 바이트코드란 무엇인가
1. 프로그램을 실행시키는 주체는 컴퓨터이며, 프로그램은 결국 컴퓨터가 이해할 수 있는 형태로 작성되어야 한다.
2. java 파일은 사람이 만든 파일로 컴퓨터는 이해하지 못하기에 번역을 해주어야 한다.
3. 컴퓨터가 이해할 수 있는 언어로 번역하는 것은 JVM이 담당하기에 우리는 이 JVM이 이해할 수 있는 형태로 보내주기만 하면된다.
4. 이때 JVM이 이해할 수 있는 형태가 바이트코드이며 컴파일러에 의해 컴파일된 class 파일이 바이트 코드이다.

* JDK와 JRE의 차이
  * Java Development Kit
    * 자바 애플리케이션의 개발 환경.
    * 실행 환경 뿐만 아니라, 소스 파일의 컴파일러 및 디버거 등 자바 애플리케이션을 개발하기 위한 도구를 포함한다.  
  * Java Runtime Environment
    * 자바 애플리케이션의 실행 환경.
    * 이미 컴파일된 자바 애플리케이션 모듈(JAR파일, 클래스 파일)을 이용하여 실행할 수 있다.
    * JRE는 JDK에 포함되며 JRE + 개발도구 = JDK이다.



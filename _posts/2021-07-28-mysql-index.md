---
title:  "MySQL - index"

categories:
  - mysql
tags:
  - index
comments: true

last_modified_at: 2021-08-09
---

미완
정산 시스템 개발을 하며 MySQL을 사용하는데, 인덱스를 잘 알지 못해 헤맨 경험이 있어 공부를 하며 정리한 내용을 작성합니다.

저와 같은 상황에 맞이한 분들과 공유하고자 포스트를 작성할 것이며, 제가 이해하며 잘못된 부분이 있을 수 있습니다.

혹여나 잘못된 부분이 있다면 댓글 부탁드립니다.

## 랜덤 I/O와 순차 I/O
랜덤 I/O란 

## Index란
쉽게 인덱스를 설명하자면 메모리 영역에 `목차`를 생성하는 것입니다. <br>
조건절에 자주 사용되는 컬럼들을 기준으로 목차를 생성하여 조회 성능을 향상시킬 수 있도록 도와주는 것이지요.

잠시 인덱스에 대한 추가 설명 전 Tree구조에 대하여 짚고 넘어가겠습니다.

## B-Tree
![1](/assets/images/b-tree.png)

[출처: 위키백과:B-트리](https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC)

B-Tree는 아래와 같은 특징을 같습니다.
* B-Tree는 자식 노드기 최대 2개인 `이진 트리`를 확장한 자식 노드가 2개 이상인 `균형 트리`이다.
* `최대 가질 수 있는 자식 노드에 개수(N)`에 따라 `N차 B-Tree`라고 한다.
* 최 상단의 노드를 `Root Node`, 중간 노드들을 `Branch Node`, 최 하단 노드를 `Leaf Node`라고 한다.
* Root Node는 `최소 2개의 자식 노드`를 갖고 자식 노드의 수는 `부모 노드의 데이터 개수 + 1` 이다.
* 모든 노드가 키를 갖고 있으며 데이터를 갖고 있을 수 있으며 키로 `정렬`되어 있어 있어야 한다. 
  * 데이터는 DB Index 구조에서 `Disk Block의 포인터`이다.
* 키는 중복되지 않는다.
* 탐색 방법은 Root Node를 시작으로 `하향식`으로 탐색한다.
* 모든 리프 노드까지의 Height가 동일하기 때문에 어떤 데이터를 탐색하던 `logN의 성능`을 낸다.
* 균형 트리이기 때문에 데이터의 삽입, 수정, 삭제 시 균형을 다시 맞추는 작업이 필요하다.
* Mongo DB는 B-Tree 인덱스를 사용한다.

## B+Tree
![1](/assets/images/b+tree.png)

[출처: 위키백과:B+트리](https://ko.wikipedia.org/wiki/B%2B_%ED%8A%B8%EB%A6%AC)

B+Tree는 B-Tree를 확장한 개념으로 B-Tree와 대부분 같은 특징을 갖고 있으며 아래와 같은 차이가 있습니다.
* Leaf Node를 제외한 노드는 `Key`만 갖고 있다.
  * 키값에 대한 데이터를 저장하지 않기에 노드 사이즈를 더 많이 이용할 수 있다.
  * 이러한 이유로 B+Tree가 B-Tree보다 높이가 더 낮다.
* Leaf Node가 아닌 비단말 노드의 Key는 Leaf Node에 접근하기 위한 용도로만 사용된다.
* 부모 노드의 키는 오른쪽 자식노드의 첫번째에 위치한다.
* 데이터는 모두 Leaf Node에만 저장되어 있으며 `Leaf Node간 Linked List`로 연결되어 있다.
  * 데이터는 Leaf Node에만 존재하기에 Key 중복이 있다. (부모 노드의 데이터가 Leaf에 있다)
* Leaf Node는 다음 형제 노드에 대한 포인터를 갖고 있어 중위 순회 없이 순차적 순회가 가능하다.
  * 이 특징으로 범위 탐색에 유리하다.
  * B-Tree는 루트에서 찾고자 하는 데이터가 있는경우 탐색이 한번에 끝나지만 B+Tree는 Leaf Node까지 탐색이 필수이다.

## 다시 본론으로 돌아와서..
MySQL의 엔진인 InnoDB는 B+Tree를 기반으로 인덱스 테이블을 생성합니다. <br>
B+tree 특성 상, 데이터 조회 시 성능을 향상 시킬 수 있지만 데이터의 생성, 수정, 삭제시에는 테이블의 균형을 다시 맞추는 작업이 필요하기 때문에 성능이 더욱 안좋아지게 됩니다.

그렇기에 인덱스 테이블을 구성할 때 변경이 잦지 않으며 조회 시 좋은 성능을 낼 수 있는 컬럼을 선정하는 것이 중요합니다.
인덱스의 컬럼을 선정할 때 아래와 같은 기준을 충족하는지 확인해보는 것이 좋습니다.

## 효율적인 index 선정 기준
### 단일 인덱스
단일 인덱스는 하나의 컬럼으로 이루어진 인덱스를 의미합니다.
이 경우 인덱스 컬럼으로 Cardinality가 가장 높은 것을 선정합니다.
> Cardinality란 컬럼의 중복된 정도를 의미하며 Cardinality가 높은 것은 중복도가 낮고 분포도가 높음을 의미합니다. 반대로 Cardinality가 낮은 것은 중복도가 높고 분포도가 낮음을 의미합니다.

Cardinality가 낮은 컬럼을 선정하는 경우 인덱스를 통해 걸러낼 수 있는 데이터가 적기 떄문에 좋은 성능을 기대하기 어렵습니다.
> 인덱스 손익분기점을 넘기는 경우 랜덤 I/O인 index scan보다 순차 I/O인 table full scan이 효율적입니다..

### 인덱스 손익분기점?



하지만 

### 복합 인덱스



### 참고
[jojoldu님 블로그 - [mysql] 인덱스 정리 및 팁](https://jojoldu.tistory.com/243?category=761883)
---
title:  "ORM 패러다임 불일치"
excerpt: "ORM 패러다임 불일치에 대하여"

categories:
  - spring-data-jpa

last_modified_at: 2021-05-16
---

### 객체를 관계에 매핑하는데 발생하는 문제점과 해결책

* 밀도(Granularity) 문제

| 객체 | 릴레이션 |
| --- | --- |
| 다양한 크기의 객체를 만들 수 있음 | 테이블 |
| 커스텀한 타입 만들기 쉬움 | 기본 데이터 타입(User Defined Type은 추천하지 않음) |


* 서브타입(SubType) 문제

| 객체 | 릴레이션 |
| --- | --- |
| 상속 구조 만들기 쉬움 | 테이블은 상속이라는 개념이 없으며 상속을 구현한다 해도 표준 기술이 아님 |
| 다형성 | 다형적 관계를 표현할 방법이 없음 |

* 식별성(Identity) 문제

| 객체 | 릴레이션 |
| --- | --- |
| 레퍼런스 동일성 (==) | 주키 (primary key) |
| 인스턴스 동일성 (equals()) |  |

* 관계(Association) 문제

| 객체 | 릴레이션 |
| --- | --- |
| 객체 레퍼런스로 관계 표현 | 외래키(FK)로 관계 표현 |
| 군본적으로 '방향'이 존재 | '방향'이 없으며 JOIN을 통해 타 테이블을 묶을 수 있음 |
| 다대다 관계를 가질 수 있음 | 다대다 관계가 없으며, 조인 테이블 또는 링크 테이블을 사용하여 1대다, 다대1 관계로 풀어야함 |

* 데이터 네비게이션(Data Navigation) 문제

| 객체 | 릴레이션 |
| --- | --- |
| 레퍼런스를 이용하여 다른 객체로 이동 가능 | 관게 측면에서 이런 방식은 데이터를 조회하는데 있어 매우 비효율적임 |
| 콜렉션 순회 가능 | 데이터베이스에 요청을 최대한 적게 보내는 것이 효율적이며 너무 많은 데이터를 가져오려고 하는 것도 문제이다. |
|  | lazy loading을 하자니 n+1 select 문제 밠생 |

객체와 릴레이션간의 패러다임 자체가 많이 다르기에 둘 사이의 차이가 굉장히 크다
이 차이를 줄이고 서로간 호환이 가능한 형태로 사용할 수 있게끔 해주는 것이 ORM이라고 할 수 있겠다.

참고: [https://www.inflearn.com/course/스프링-데이터-jpa](https://www.inflearn.com/course/스프링-데이터-jpa)